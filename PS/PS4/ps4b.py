# Problem Set 4B
# Name:
# Collaborators:

import random
import copy

class Message(object):
    def __init__(self, input_text):
        '''
        Initializes a Message object

        input_text (string): the message's text

        a Message object has one attribute:
            the message text
        '''
        self.text = input_text

        # def __str__(self):
        #     return f"Message: {self.text}"

          # delete this line and replace with your code here

    def __repr__(self):
        '''
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        '''

        return f'''Message('{self.get_text()}')'''

    def get_text(self):
        '''
        Used to access the message text outside of the class

        Returns: (string) the message text
        '''
        return self.text  # delete this line and replace with your code here

    # def shift_char(self, char, shift):
    #     '''
    #     Used to shift a character as described in the pset handout
    #
    #     char (string): the single character to shift.
    #                 ASCII value in the range: 32<=ord(char)<=126
    #     shift (int): the amount to shift char by
    #
    #     Returns: (string) the shifted character with ASCII value in the range [32, 126]
    #     '''
    #     start = 32
    #     shifted_index = (ord(char) + shift)
    #     if shifted_index > 126:
    #         shifted_index = shifted_index%126 + (start-1)
    #     elif shifted_index < 32:
    #             shifted_index = (shifted_index - 32) + 127
    #     return chr(shifted_index)
    def shift_char(self, char, shift):
        """
        char (str): 32 <= ord(char) <= 126 범위의 단일 문자
        shift (int): 문자에 적용할 시프트량

        반환값: (str) 시프트된 결과 문자 (ASCII 범위 32~126 유지)
        """
        start = 32
        end = 126
        char_range = end - start + 1  # 95 (ASCII 32~126 길이)

        # (원본 ord - start + shift)를 95로 나눈 나머지를 다시 start로 이동
        shifted_ord = (ord(char) - start + shift) % char_range + start
        return chr(shifted_ord)

    def apply_pad(self, pad):
        '''
        Used to calculate the ciphertext produced by applying a one time pad to the message text.
        For each character in the text at index i shift that character by
            the amount specified by pad[i]

        pad (list of ints): a list of integers used to encrypt the message text
                        len(pad) == len(the message text)

        Returns: (string) The ciphertext produced using the one time pad
        '''
        ciphertext_chars = []
        for i, char in enumerate(self.text):
            shift_amount = pad[i]
            shifted_char = self.shift_char(char, shift_amount)
            ciphertext_chars.append(shifted_char)



class PlaintextMessage(Message):
    def __init__(self, input_text, pad=None):
        '''
        Initializes a PlaintextMessage object.

        input_text (string): the message's text
        pad (list of ints OR None): the pad to encrypt the input_text or None if left empty
            if pad is not None then len(pad) == len(self.input_text)

        A PlaintextMessage object inherits from Message. It has three attributes:
            the message text
            the pad (list of integers, determined by pad
                or generated randomly using self.generate_pad() if pad is None)
            the ciphertext (string, input_text encrypted using the pad)
        '''

        super().__init__(input_text)
        if pad is None:
            self.pad = self.generate_pad()
        else:
            self.pad = pad
        self.change_pad(pad)

    def __str__(self):
        return self.__repr__()
    def __repr__(self):
        '''
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        '''
        return f'''PlaintextMessage('{self.get_text()}', {self.get_pad()}, {self.get_ciphertext()})'''

    def generate_pad(self):
        '''
        Generates a one time pad which can be used to encrypt the message text.

        The pad should be generated by making a new list and for each character
            in the message chosing a random number in the range [0, 110) and
            adding that number to the list.

        Returns: (list of integers) the new one time pad
        '''
        self.pad = [random.randint(0, 109) for i in range(len(self.text))]
        # for i in range(len(self.text)):
            # self.pad.append(random.randint(0, 109))
          # delete this line and replace with your code here
        return self.pad

    def get_pad(self):
        '''
        Used to safely access your one time pad outside of the class

        Returns: (list of integers) a COPY of your pad
        '''
        return copy.deepcopy((self.pad))
          # delete this line and replace with your code here

    def get_ciphertext(self):
        '''
        Used to access the ciphertext produced by applying pad to the message text

        Returns: (string) the ciphertext
        '''
        return self.ciphertext

    def change_pad(self, new_pad):
        '''
        Changes the pad used to encrypt the message text and updates any other
        attributes that are determined by the pad.

        new_pad (list of ints): the new one time pad that should be associated with this message.
            len(new_pad) == len(the message text)

        Returns: nothing
        '''
        self.pad = new_pad
        self.ciphertext = ''
        for i in range(len(self.text)):
            self.ciphertext += self.shift_char(self.text[i], self.pad[i]) # delete this line and replace with your code here

message = PlaintextMessage("Aaa", [1,2,3])
message2 = PlaintextMessage("Hello!", [5, 10, 2, 3, 0, 2])

print(message)
print(PlaintextMessage.__repr__(message2))
class EncryptedMessage(Message):
    def __init__(self, input_text):
        '''
        Initializes an EncryptedMessage object

        input_text (string): the ciphertext of the message

        an EncryptedMessage object inherits from Message. It has one attribute:
            the message text (ciphertext)
        '''
        super().__init__(input_text)



    def __repr__(self):
        '''
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        '''
        return f'''EncryptedMessage('{self.get_text()}')'''

    def decrypt_message(self, pad):
        '''
        Decrypts the message text that was encrypted with pad as described in the writeup

        pad (list of ints): the new one time pad used to encrypt the message.
            len(pad) == len(the message text)

        Returns: (PlaintextMessage) the decrypted message (containing the pad)
        '''
        minus_pad = [(-1)* i for i in pad]
        return PlaintextMessage(self.text, minus_pad)

message = EncryptedMessage("$ip!")
decrypted_message = message.decrypt_message([5, 1, 7, 2])
print(decrypted_message)
          # delete this line and replace with your code here
